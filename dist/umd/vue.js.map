{"version":3,"file":"vue.js","sources":["../../src/util/index.js","../../src/observe/array.js","../../src/observe/index.js","../../src/state.js","../../src/compiler/parser-html.js","../../src/compiler/index.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 工具库\r\n/**\r\n * \r\n * @param {*} data  当前数据是不是对象\r\n */\r\n\r\nexport function isObject(data){\r\n    return typeof data === 'object' && data !==null\r\n}\r\n/**\r\n * 给对象增加属性\r\n * @param {*} data \r\n * @param {*} key \r\n * @param {*} value \r\n */\r\nexport function def(data,key,value){\r\n    Object.defineProperty(data,key,{\r\n        enumerable:false,\r\n        configurable:false,\r\n        value:value\r\n    })\r\n}\r\n/**\r\n * 取值时实现代理效果\r\n *  // 为了让用户更好的使用，我希望可以直接vm.xx。vm直接取值\r\n * @param {*} vm \r\n * @param {*} source \r\n * @param {*} key \r\n */\r\nexport function proxy(vm, source, key) {\r\n    Object.defineProperty(vm, key, {\r\n        get() {\r\n            return vm[source][key]\r\n        },\r\n        set(newValue) {\r\n            vm[source][key] = newValue\r\n        }\r\n    })\r\n}\r\n\r\n\r\n","// 这里为什么要重写数组的方法呢，是因为用户是在前台把数组更新了，但是我们怎么获取更新的数组呢，只能在监听到用户传的方法也就是前面的value.__protp__=arrayMethods获取到所有的方法，然后这边在根据方法和传入的值在进行数组更新，然后在返回新的数组\r\n\r\n\r\n\r\n//  我要重写数组的哪些方法  ：7个  push shift  unshift  pop  reverse sort splice 会导致数组本身发生变化\r\n// slice（）这个方法并不会改变数组，就不用去通知了也不需要劫持，我们只监听数组变了的方法\r\n\r\n\r\n// 这就是原型链查找问题，会向上查找，先查找我重写的，重写的没有会继续向上查找\r\nlet oldArrayMethods = Array.prototype;//设置这个变量是为了如果用户调用了我们没有重写的方法（比如slice），会直接调用Array基类的方法\r\n// value.__propo__ = arrayMethods(数组通过原型链指向了arrayMethods)\r\n//arrayMethods.__propo__ = oldArrayMethods(arrayMethods通过原型链指向了oldArrayMethods)\r\nexport const arrayMethods = Object.create(oldArrayMethods); // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 也就是这端代码 等于 arrayMethods.__propo__ = oldArrayMethods\r\n\r\n\r\nconst methods = [\r\n    'push',\r\n    'shift',\r\n    'unshift',\r\n    'pop',\r\n    'sort',\r\n    'splice',\r\n    'reverse'\r\n]\r\n\r\nmethods.forEach(method=>{\r\n    // 在arrayMethods这个属性上增加上面那些方法，调这些方法的时候会传入很多参数\r\n    arrayMethods[method] = function(...args){//...agrs是{name: \"zf\", age: 3}\r\n        console.log('用户调用了方法');// AOP 切片编程  \r\n        const result = oldArrayMethods[method].apply(this,args);//调用原生的数组方法,这里的this指的是value,因为是value调用的,这个result返回的是value的length\r\n\r\n\r\n       // 判断：如果添加的元素可能还是一个对象\r\n\r\n        let inserted;//当前用户插入的元素\r\n        let ob =this.__ob__;//这里的this是指value，因为value在外面定义了value.__ob__=this;，这指向Observer的实例，而这个实例又有observerArray方法，所以可以调用observerArray方法\r\n        switch(method){\r\n            case 'push':\r\n            case 'usnshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':  //3个  新增的属性  splice 有删除 新增 的功能 arr.splice(0,1，{name:1})\r\n                inserted = args.slice(2);     //获取到最后新增的数据截取出来\r\n            default:\r\n                break;            \r\n        }\r\n        if(inserted) ob.observerArray(inserted);//将新增对象属性继续观测\r\n        return result;//这是是为了上面arrayMethods[method]=result,这个result就是为了改变this指向，让外面调用原生的方法\r\n    }\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// 把data中的数据 都使用Object.defineProperty重新定义  这是一个es5的方法\r\n// Object.defineProperty不能兼容ie8及以下，vue2无法兼容ie8版本\r\nimport {isObject,def} from '../util/index'\r\nimport {arrayMethods} from './array.js'\r\n/**\r\n *   步骤一：先创建一个Observer类进行数据监听，如果传入进来的data是个  对象  的话，遍历对象，用Object.defineProperty中的get和set方法进行数据变化的监听，如果对象里面嵌套对象，那么就用递归的方式进行深度监听\r\n *   步骤二：如果传入进来的data是个  数组   的话，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能，所以为了不给数组的索引进行get，set监听，遍历数组获得每个对象，在给里面的每个对象进行监听\r\n *    步骤三：当data是个数组的话，如果用户对这个数组进行了方法调用改变数组（比如用了push，unshift等方法）我们也要对方法进行重写，进行监听，并重新赋值。\r\n * （这一步的大概逻辑是：会导致数组本身发生变化的方法写成一个数组，然后遍历在调用原生方法，将原生方法进行输出，具体看array.js）\r\n *       \r\n * \r\n * \r\n * \r\n * \r\n * \r\n */\r\n\r\n\r\n\r\n/* 步骤一 start*/ \r\n\r\n//创建一个Observer的类\r\nclass Observer{\r\n   constructor(value){//这里的constructor是es6的新写法，一个类必须有 constructor 方法，一般 constructor 方法返回实例对象 this ，但是也可以指定  constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。\r\n    //这是constructor的概念https://www.jianshu.com/p/fc79756b1dc0\r\n\r\n\r\n/* 步骤三.2 start*/ \r\n//value.__ob__=this;//我给每一个监控过的对象都增加一个__ob__属性，这的this指的是Observer的实例,为了给后面的方法调用observerArray，进行数据监听\r\n// 上面的方法不能直接在vulue上加属性，因为下面的observe会进行数据监听，它会以为value增加新的数据，而上面的方法只是为了以后数据调用代码而进行赋值的，所以只能用下面的方法\r\n     def(value,'__ob__',this)\r\n/* 步骤三 end*/\r\n\r\n/* 步骤二 start*/ \r\n\r\n    // 如果是传进来的是数组，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能\r\n    if(Array.isArray(value)){\r\n        //如果是数组的话并不会对索引进行观测，因为会导致性能问题\r\n        // 前端开发中很少很少  去操作索引  push  shift  unshift\r\n\r\n/* 步骤三.1 start*/ \r\n       value.__proto__= arrayMethods;\r\n/* 步骤三 end*/ \r\n\r\n\r\n        // 如果数组里放的是对象我在监控\r\n        this.observerArray(value);\r\n    }else{\r\n        //vue如果数据的层次过多，需要递归的去解析对象中的属性，依次增加set和get方法\r\n        this.walk(value)// 先考虑一步的数据\r\n    }\r\n\r\n   }\r\n\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤二 start*/   \r\n//这个方法是为了不给数组的索引进行get，set监听，直接遍历数组获得每个对象，在给对象进行监听\r\n   observerArray(value){//value是[{}],用observe监控了数组的每一项\r\n        for(let i=0; i<value.length;i++){\r\n            observe(value[i])\r\n        }\r\n   }\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤一 start*/ \r\n   walk(data){\r\n       let keys = Object.keys(data); //[name,age,address]\r\n\r\n    //    for(let i=0;i<keys.length;i++){\r\n    //         let key =keys[i];\r\n    //         let value =data[key];\r\n    //         defineReactive(data,key,value);//定义响应式数据\r\n    //     }\r\n    // 可以简化为下面的代码\r\n        keys.forEach((key)=>{\r\n            defineReactive(data,key,data[key]);//定义响应式数据\r\n        })\r\n\r\n      \r\n   }\r\n/* 步骤一 end*/ \r\n}\r\n/* 步骤一 start*/  \r\nfunction defineReactive(data,key,value){\r\n    observe(value);//这里的调用，是为了递归，获取到对象中的对象的属性:递归实现深度检测，但是如果层级太多使用递归会很浪费性能\r\n    Object.defineProperty(data,key,{\r\n        get(){//获取值的时候作一些操作\r\n           return value;\r\n        },\r\n        set(newValue){//当数据发生变化，也可以设置一些操作\r\n\r\n            console.log('更新数据')\r\n\r\n\r\n           if(newValue === value)  return;\r\n           observe(newValue);//继续劫持用户设置的值，因为有可能用户设置的值是一个对象；这里深度劫持就会在这个对象里有set和get方法，就能再次进行更改监听\r\n           value = newValue\r\n        }\r\n    })\r\n}\r\n/* 步骤一 end*/ \r\n\r\n/* 步骤一 start*/  \r\n\r\n// 这里是输出Observer观察到的数据\r\nexport function observe(data){\r\n    let isObj = isObject(data);\r\n    if(!isObj){\r\n        return;\r\n    }   \r\n   return new Observer(data)  // 用来观测数据\r\n \r\n}\r\n/* 步骤一 end*/\r\n\r\n\r\n","import { observe } from './observe/index.js'\r\nimport {proxy} from './util/index.js'\r\nexport function initState(vm) {\r\n    const opts = vm.$options;\r\n    //监测的顺序 vue的数据来源  属性  方法  数据  计算属性  watch\r\n    if (opts.props) {\r\n        initProps(vm);\r\n    }\r\n    if (opts.methods) {\r\n        initMethod(vm)\r\n    }\r\n    if (opts.data) {\r\n        initData(vm)\r\n    }\r\n    if (opts.computed) {\r\n        initComputed(vm)\r\n    }\r\n    if (opts.watch) {\r\n        initWatch(vm)\r\n    }\r\n}\r\nfunction initProps() { }\r\nfunction initMethod() { }\r\nfunction initData(vm) {\r\n    //   数据初始化工作\r\n    let data = vm.$options.data;//用户传递的data\r\n    data = vm._data = typeof data === 'function' ? data.call(vm) : data;\r\n    // console.log(data);\r\n    // 对象劫持  用户改变了数据  我希望可以得到通知  后可以  刷新页面\r\n    // MVVM模式 数据变化可以驱动视图变化\r\n\r\n    //  Object.defineroperty() 给属性增加get方法和set方法\r\n\r\n\r\n    // 为了让用户更好的使用，我希望可以直接vm.xx。vm直接取值\r\n    for (let key in data) {\r\n        proxy(vm, '_data', key)\r\n    }\r\n    observe(data);//1.响应式原理\r\n\r\n}\r\nfunction initComputed() { }\r\nfunction initWatch() { }","\r\n\r\n// vue源码\r\n// ?:匹配不补货\r\n\r\nconst ncname = '[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*'//命名空间：表示能匹配到abc-aaa这样的一个字符串\r\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`//命名空间标签：<aaa:asdee>\r\n// 匹配开始标签开始部分\r\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)//标签开头的正则，捕获的内容是标签名\r\n\r\n\r\n/**\r\n * 这是验证上面的正则是否正确\r\n * let r = '<a:b>'.match(startTagOpen);\r\n * console.log(r)\r\n * \r\n * 获得这样的东西  [\"<a:b\", \"a:b\", index: 0, input: \"<a:b>\", groups: undefined]\r\n * \r\n * arguments[0] = 匹配到的标签  arguments[1] = 匹配到的标签名字 \r\n */\r\n\r\n\r\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)// 匹配标签结尾的闭比如</div>\r\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/ // 匹配属性\r\nconst startTagClose = /^\\s*(\\/?)>/   // 匹配标签结束的 >\r\n\r\n\r\n\r\nlet root = null;//ast语法树的树根\r\nlet currentParent;//标识当前父亲是谁\r\nlet stack = [];\r\nconst ELEMENT_TYPE = 1;\r\nconst TEXT_TYPE = 3;\r\n\r\nfunction createASTElement(tagName, attrs) {\r\n    return {\r\n        tag: tagName,\r\n        type: ELEMENT_TYPE,\r\n        children: [],\r\n        attrs,\r\n        parent: null\r\n    }\r\n}\r\n\r\nfunction start(tagName, attrs) {\r\n    //console.log('开始标签：', tagName, '属性是：', attrs);\r\n    //遇到开始标签 就创建一个ast元素\r\n    let element = createASTElement(tagName, attrs);\r\n    if (!root) {\r\n        root = element;\r\n    }\r\n    currentParent = element;//把当前元素标记成父ast树\r\n    stack.push(element);//将开始标签存放在栈中\r\n\r\n}\r\nfunction chars(text) {\r\n    // console.log('文本是：', text)\r\n    text =text.replace(/\\s/g,'');\r\n    if(text){\r\n        currentParent.children.push({\r\n            text,\r\n            type:TEXT_TYPE\r\n        })\r\n    }\r\n}\r\nfunction end(tagName) {\r\n    // console.log('结束标签', tagName)\r\n    let element = stack.pop();//拿到的是ast对象\r\n    //我要标识当前这个p是属于这个div的儿子的\r\n    currentParent = stack[stack.length-1];\r\n    if(currentParent){\r\n        element.parent = currentParent;\r\n        currentParent.children.push(element);//实现了一个树的父子关系\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function parseHTML(html) {\r\n    // 不停的解析html\r\n    while (html) {\r\n        let textEnd = html.indexOf('<');\r\n        if (textEnd == 0) {\r\n            //   如果当前索引为0  肯定是一个标签  开始标签  结束标签\r\n            let startTagMatch = parseSartTag();//通过这个方法获取到匹配的结果 tagName，attrs\r\n            if (startTagMatch) {\r\n                start(startTagMatch.tagName, startTagMatch.attrs)//1.解析开始标签\r\n                continue;//如果开始标签匹配完毕后，继续下一次 匹配\r\n            }\r\n            let endTagMatch = html.match(endTag);\r\n            if (endTagMatch) {\r\n                advance(endTagMatch[0].length);\r\n                end(endTagMatch);//2.解析结束标签\r\n                continue;\r\n            }\r\n        }\r\n        let text;\r\n        if (textEnd >= 0) {\r\n            text = html.substring(0, textEnd)\r\n        }\r\n        if (text) {\r\n            advance(text.length);\r\n            chars(text)//3.解析文本\r\n        }\r\n    }\r\n    function advance(n) {\r\n        html = html.substring(n);\r\n    }\r\n    function parseSartTag() {\r\n        let start = html.match(startTagOpen)\r\n        if (start) {\r\n            const match = {\r\n                tagName: start[1],\r\n                attrs: []\r\n            }\r\n            advance(start[0].length);//将标签删除\r\n\r\n            let end, attr;\r\n            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\r\n                // 将属性进行解析\r\n                advance(attr[0].length);//将属性去掉\r\n                match.attrs.push({\r\n                    name: attr[1],\r\n                    value: attr[3] || attr[4] || attr[5]\r\n                });//放在了attrs这个属性中\r\n\r\n            }\r\n            if (end) {//去掉开始标签的 >\r\n                advance(end[0].length);\r\n                return match\r\n            }\r\n        }\r\n    }\r\n    return root;\r\n}","//将html变成函数的话，会用到ast语法树\r\n/*ast语法树  和 虚拟到dom有什么区别\r\nast语法树 是 用对象来编译html语法的（下面的原理）\r\n虚拟dom 是  用对象来描述dom节点的（也就是那个html下面有div标签，div下面有p，span标签等的dom节点）\r\n\r\n\r\n\r\nrender函数返回的是虚拟dom，现在做的是把template变成render函数\r\n\r\n\r\n把html不停的循环，拿出来之后组成一个树，这个树描述了一个dom结构\r\n*/\r\n\r\nimport { parseHTML } from './parser-html'\r\n\r\nconst defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g // 匹配默认的分隔符 \"{{}}\"\r\n\r\nfunction genProps(attrs) {//处理属性，拼接成属性的字符串\r\n    let str = '';\r\n    for (let i = 0; i < attrs.length; i++) {\r\n        let attr = attrs[i];\r\n        if (attr.name === 'style') {\r\n            //style=\"color:red;font-size:14px\" => {style:{color:'red'},id:name}\r\n            let obj = {};\r\n            attr.value.split(';').forEach(item => {\r\n                let [key, value] = item.split(':');\r\n                obj[key] = value\r\n            });\r\n            attr.value = obj;\r\n        }\r\n        str += `${attr.name}:${JSON.stringify(attr.value)},`\r\n    }\r\n    return `{${str.slice(0, -1)}}`\r\n}\r\nfunction genChildren(el) {\r\n    let children = el.children;\r\n    if (children && children.length > 0) {\r\n        return `${children.map(c => gen(c)).join(',')}`\r\n    } else {\r\n        return false\r\n    }\r\n}\r\nfunction gen(node) {\r\n    if (node.type == 1) {\r\n        //元素标签\r\n        return generate(node)\r\n    } else {\r\n        let text = node.text;// a {{name}}  b{{age}}  c\r\n        // _v(\"a\"+_s(name)+\"b\"+_s(age)+'c')\r\n        let tokens = [];\r\n        let match, index;\r\n        let lastIndex = defaultTagRE.lastIndex = 0;   // 正则的问题 lastIndex设为0才可以用exec正常匹配（具体为什么自己百度） 只要全局匹配，就需要将lastIndex每次匹配的时候就调到0处\r\n        while (match = defaultTagRE.exec(text)) {\r\n            index = match.index;\r\n            if (index > lastIndex) {\r\n                tokens.push(JSON.stringify(text.slice(lastIndex, index)));\r\n            }\r\n            tokens.push(`_s(${match[1].trim()})`)\r\n            lastIndex = index + match[0].length;\r\n        }\r\n        if (lastIndex < text.length) {\r\n            tokens.push(JSON.stringify(text.slice(lastIndex)))\r\n        }\r\n\r\n\r\n        return `_v(${tokens.join('+')})`;\r\n    }\r\n}\r\n\r\nfunction generate(el) {//[{name:'id',value:'app'},{}]  => {id:app,a:1,b:2}\r\n    let children = genChildren(el);\r\n    let code = `_c(\"${el.tag}\",${\r\n        el.attrs.length ? genProps(el.attrs) : 'undefined'\r\n        }${children ? `,${children}` : ''\r\n        }) `\r\n    return code;\r\n}\r\n\r\nexport function compileToFunction(template) {\r\n    //console.log(template, '---');\r\n    //1）解析html字符串，将html字符串 => ast语法树\r\n    let root = parseHTML(template)\r\n    // console.log(root)\r\n\r\n\r\n    let code = generate(root);\r\n\r\n    //2)需要将ast语法树生成最终的render函数  就是字符串拼接 （模板引擎）\r\n    // 核心思路就是将模板转换成 下面这段字符串\r\n    // <div id=\"app\">hello<p>{{name}}</p><span>{{age}}</span></div>\r\n    // 将ast树，再次转换成js的语法树\r\n    // _c('div',{id:'app'},_c('p',undefined,_v(_s(name))),_c('span',undefined,_v(_s(age))))\r\n\r\n    // 所有的模板引擎实现，都需要new Function + with\r\n    //这里加的with方法是为了实现ƒ anonymous(\r\n    // ) {\r\n    //     with(this){return _c(\"div\",{id:\"app\",style:{\"color\":\" red\"}},_v(\"hello\"),_c(\"p\",undefined,_v(_s(name))),_c(\"span\",undefined,_v(_s(age)))\r\n\r\n    //         )\r\n\r\n    //         } \r\n    //     }\r\n    // 这个函数，也就是render这个函数的，因为这个才是将模板进行编译的\r\n    let renderFn = new Function(`with(this){return ${code}} `)\r\n    // console.log(renderFn);\r\n\r\n    //vue的render  它返回的是虚拟dom\r\n    return renderFn\r\n}\r\n\r\n/**\r\n * 通过上面的正则，可以把下面的html编译成\r\n * start div:  attr:[{name:'id',value:'app'}]\r\n * start p\r\n * text hello\r\n * end p\r\n * end div\r\n */\r\n/*\r\n<div id=\"app\">\r\n    <p>hello</p>\r\n</div>\r\n//上面的html就会变成下面的抽象的语法，这就是ast语法树\r\n这个root就是ast语法树\r\nlet root ={\r\n    tag:'div',\r\n    attrs:[//属性\r\n        {name:'id',value:'app'}\r\n    ],\r\n    parent:null,\r\n    type:1,//它是什么类型，元素类型为1\r\n    children:[{\r\n        tag:'p',\r\n        attrs:[],\r\n        parent:root,\r\n        children:[{\r\n            text:'hello',\r\n            type:3,//文本类型为1\r\n            }]\r\n    }]\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import { initState } from './state'\r\n\r\nimport { compileToFunction } from './compiler/index.js'\r\n// 在原型上添加一个init方法\r\nexport function initMixin(Vue) {\r\n    Vue.prototype._init = function (options) {\r\n        //    数据的劫持\r\n        const vm = this;//vue中使用this.$options 指代\r\n        vm.$options = options;\r\n\r\n        // 初始化状态\r\n        initState(vm);//分割代码（这里面有1.数据劫持）\r\n\r\n\r\n\r\n\r\n\r\n        // 2.模板编译\r\n        // 如果用户传入了el属性  需要将页面渲染出出来\r\n        // 如果用户传入了el  就要实现挂载流程\r\n        if (vm.$options.el) {\r\n            vm.$mount(vm.$options.el);\r\n        }\r\n\r\n    }\r\n    Vue.prototype.$mount = function (el) {\r\n        const vm = this;\r\n        const options = vm.$options;\r\n        el = document.querySelector(el);\r\n\r\n        // 默认先会查找有没有render方法，没有render  会 采用template， template也没有就用el中的内容\r\n        if (!options.render) {\r\n            // 对模板进行编译\r\n            let template = options.template;//取出模板\r\n            if (!template && el) {\r\n                template = el.outerHTML;\r\n            }\r\n            // console.log(template);\r\n            /*这是拿到的template的模板\r\n            <div id=\"app\">\r\n                <p>{{name}}</p>\r\n                <span>{{age}}</span>\r\n            </div>*/\r\n\r\n            // 我们需要将template  转换成render方法\r\n            // vue1.0是用的纯字符串编译，正则转换的方式，性能不高；vue2.0引用的是虚拟dom\r\n            /* 将上面的拿到的template模板，用render函数写成：\r\n            render(){  //_c是creatElement创建一个元素div； 有一些属性{id:'app'}： \r\n            有俩个儿子  p没有属性undefined; p里面有文本，创建一个文本_v;  _s表示的是json.stringify取值，转成一个对象格式或字符串格式，创建出来一个文本;  span同理\r\n            这样就创建出一个虚拟节点，变成上面的html\r\n                return _c('div',{id:'app'},_c('p',undefined,_v(_s(name))),_c('span',undefined,_v(_s(age))))\r\n            }\r\n            */\r\n            // 模板进行编译用compileToFunction这个函数(自己封装的)，也就是把template这个html编译成一个函数\r\n            const render = compileToFunction(template);\r\n            options.render = render;//这个是为了用户传了render用用户传的，用户没传，就用自己写的\r\n        }\r\n\r\n        // options.render\r\n        console.log(options.render, vm)\r\n\r\n        // 3.挂载组件：渲染当前的组件或者叫挂载这个组件\r\n        mountComponent();\r\n\r\n\r\n    }\r\n}\r\n\r\n","// 自写vue的核心代码,只是vue的一个声明\r\nimport {initMixin} from './init';\r\nfunction Vue(options){\r\n    //进行vue的初始化操作\r\n    this._init(options);\r\n\r\n}\r\n// 通过引入文件的方式 给vue原型上添加方法\r\ninitMixin(Vue)  //给vue原型上添加一个_init方法\r\nexport default Vue"],"names":["isObject","data","def","key","value","Object","defineProperty","enumerable","configurable","proxy","vm","source","get","set","newValue","oldArrayMethods","Array","prototype","arrayMethods","create","methods","forEach","method","console","log","args","result","apply","inserted","ob","__ob__","slice","observerArray","Observer","isArray","__proto__","walk","i","length","observe","keys","defineReactive","isObj","initState","opts","$options","props","initData","computed","watch","_data","call","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","root","currentParent","stack","ELEMENT_TYPE","TEXT_TYPE","createASTElement","tagName","attrs","tag","type","children","parent","start","element","push","chars","text","replace","end","pop","parseHTML","html","textEnd","indexOf","startTagMatch","parseSartTag","endTagMatch","match","advance","substring","n","attr","name","defaultTagRE","genProps","str","obj","split","item","JSON","stringify","genChildren","el","map","c","gen","join","node","generate","tokens","index","lastIndex","exec","trim","code","compileToFunction","template","renderFn","Function","initMixin","Vue","_init","options","$mount","document","querySelector","render","outerHTML","mountComponent"],"mappings":"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"}