{"version":3,"file":"vue.js","sources":["../../src/util/index.js","../../src/observe/array.js","../../src/observe/index.js","../../src/state.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 工具库\r\n/**\r\n * \r\n * @param {*} data  当前数据是不是对象\r\n */\r\n\r\nexport function isObject(data){\r\n    return typeof data === 'object' && data !==null\r\n}\r\n\r\nexport function def(data,key,value){\r\n    Object.defineProperty(data,key,{\r\n        enumerable:false,\r\n        configurable:false,\r\n        value:value\r\n    })\r\n}\r\n\r\n\r\n","\r\n\r\n//  我要重写数组的哪些方法  ：7个  push shift  unshift  pop  reverse sort splice 会导致数组本身发生变化\r\n// slice（）这个方法并不会改变数组，就不用去通知了也不需要劫持，我们只监听数组变了的方法\r\n\r\n\r\n// 这就是原型链查找问题，会向上查找，先查找我重写的，重写的没有会继续向上查找\r\nlet oldArrayMethods = Array.prototype;//设置这个变量是为了如果用户调用了我们没有重写的方法（比如slice），会直接调用Array基类的方法\r\n// value.__propo__ = arrayMethods(数组通过原型链指向了arrayMethods)\r\n//arrayMethods.__propo__ = oldArrayMethods(arrayMethods通过原型链指向了oldArrayMethods)\r\nexport const arrayMethods = Object.create(oldArrayMethods); // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 也就是这端代码 等于 arrayMethods.__propo__ = oldArrayMethods\r\n\r\n\r\nconst methods = [\r\n    'push',\r\n    'shift',\r\n    'unshift',\r\n    'pop',\r\n    'sort',\r\n    'splice',\r\n    'reverse'\r\n]\r\n\r\nmethods.forEach(method=>{\r\n    arrayMethods[method] = function(...args){\r\n        console.log('用户调用了push方法');// AOP 切片编程\r\n        const result = oldArrayMethods[method].apply(this,args);//调用原生的数组方法,这里的this指的是value,因为是value调用的\r\n       // 如果添加的元素可能还是一个对象\r\n\r\n        let inserted;//当前用户插入的元素\r\n        let ob =this.__ob__;//这里的this是指value，因为value在外面定义了value.__ob__=this;，这指向Observer的实例，而这个实例又有observerArray方法，所以可以调用observerArray方法\r\n        switch(method){\r\n            case 'push':\r\n            case 'usnshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':  //3个  新增的属性  splice 有删除 新增 的功能 arr.splice(0,1，{name:1})\r\n                inserted = args.slice(2);      \r\n            default:\r\n                break;            \r\n        }\r\n        if(inserted) ob.observerArray(inserted);//将新增属性继续观测\r\n        if(inserted)\r\n        return result;\r\n    }\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// 把data中的数据 都使用Object.defineProperty重新定义  这是一个es5的方法\r\n// Object.defineProperty不能兼容ie8及以下，vue2无法兼容ie8版本\r\nimport {isObject,def} from '../util/index'\r\nimport {arrayMethods} from './array.js'\r\n/**\r\n *   步骤一：先创建一个Observer类进行数据监听，如果传入进来的data是个  对象  的话，遍历对象，用Object.defineProperty中的get和set方法进行数据变化的监听，如果对象里面嵌套对象，那么就用递归的方式进行深度监听\r\n *   步骤二：如果传入进来的data是个  数组   的话，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能，所以为了不给数组的索引进行get，set监听，遍历数组获得每个对象，在给里面的每个对象进行监听\r\n *    步骤三：当data是个数组的话，如果用户对这个数组进行了方法调用改变数组（比如用了push，unshift等方法）我们也要对方法进行重写，进行监听\r\n *       \r\n * \r\n * \r\n * \r\n * \r\n * \r\n */\r\n\r\n\r\n\r\n/* 步骤一 start*/ \r\n\r\n//创建一个Observer的类\r\nclass Observer{\r\n   constructor(value){//这里的constructor是es6的新写法，一个类必须有 constructor 方法，一般 constructor 方法返回实例对象 this ，但是也可以指定  constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。\r\n    //这是constructor的概念https://www.jianshu.com/p/fc79756b1dc0\r\n\r\n//value.__ob__=this;//我给每一个监控过的对象都增加一个__ob__属性，这的this指的是Observer的实例\r\n// 上面的方法不能直接在vulue上加属性，因为下面的observe会进行数据监听，它会以为value增加新的数据，而上面的方法只是为了以后数据调用代码而进行赋值的，所以只能用下面的方法\r\n     def(value,'__ob__',this)\r\n\r\n/* 步骤二 start*/ \r\n\r\n    // 如果是传进来的是数组，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能\r\n    if(Array.isArray(value)){\r\n        //如果是数组的话并不会对索引进行观测，因为会导致性能问题\r\n        // 前端开发中很少很少  去操作索引  push  shift  unshift\r\n\r\n/* 步骤三 start*/ \r\n       value.__proto__= arrayMethods;\r\n/* 步骤三 end*/ \r\n\r\n\r\n        // 如果数组里放的是对象我在监控\r\n        this.observerArray(value);\r\n    }else{\r\n        //vue如果数据的层次过多，需要递归的去解析对象中的属性，依次增加set和get方法\r\n        this.walk(value)// 先考虑一步的数据\r\n    }\r\n\r\n   }\r\n\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤二 start*/   \r\n//这个方法是为了不给数组的索引进行get，set监听，直接遍历数组获得每个对象，在给对象进行监听\r\n   observerArray(value){//value是[{}],用observe监控了数组的每一项\r\n        for(let i=0; i<value.length;i++){\r\n            observe(value[i])\r\n        }\r\n   }\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤一 start*/ \r\n   walk(data){\r\n       let keys = Object.keys(data); //[name,age,address]\r\n\r\n    //    for(let i=0;i<keys.length;i++){\r\n    //         let key =keys[i];\r\n    //         let value =data[key];\r\n    //         defineReactive(data,key,value);//定义响应式数据\r\n    //     }\r\n    // 可以简化为下面的代码\r\n        keys.forEach((key)=>{\r\n            defineReactive(data,key,data[key]);//定义响应式数据\r\n        })\r\n\r\n      \r\n   }\r\n/* 步骤一 end*/ \r\n}\r\n/* 步骤一 start*/  \r\nfunction defineReactive(data,key,value){\r\n    observe(value);//这里的调用，是为了递归，获取到对象中的对象的属性:递归实现深度检测，但是如果层级太多使用递归会很浪费性能\r\n    Object.defineProperty(data,key,{\r\n        get(){//获取值的时候作一些操作\r\n           return value;\r\n        },\r\n        set(newValue){//当数据发生变化，也可以设置一些操作\r\n\r\n            console.log('更新数据')\r\n\r\n\r\n           if(newValue === value)  return;\r\n           observe(newValue);//继续劫持用户设置的值，因为有可能用户设置的值是一个对象；这里深度劫持就会在这个对象里有set和get方法，就能再次进行更改监听\r\n           value = newValue\r\n        }\r\n    })\r\n}\r\n/* 步骤一 end*/ \r\n\r\n/* 步骤一 start*/  \r\n\r\n// 这里是输出Observer观察到的数据\r\nexport function observe(data){\r\n    let isObj = isObject(data);\r\n    if(!isObj){\r\n        return;\r\n    }   \r\n   return new Observer(data)  // 用来观测数据\r\n \r\n}\r\n/* 步骤一 end*/\r\n\r\n\r\n","import {observe} from './observe/index.js'\r\nexport function initState(vm){\r\n    const opts = vm.$options;\r\n   //监测的顺序 vue的数据来源  属性  方法  数据  计算属性  watch\r\n   if(opts.props){\r\n       initProps(vm);\r\n   }\r\n   if(opts.methods){\r\n       initMethod(vm)\r\n   }\r\n   if(opts.data){\r\n       initData(vm)\r\n   }\r\n   if(opts.computed){\r\n       initComputed(vm)\r\n   }\r\n   if(opts.watch){\r\n       initWatch(vm)\r\n   }\r\n}\r\nfunction initProps(){}\r\nfunction initMethod(){}\r\nfunction initData(vm){\r\n    //   数据初始化工作\r\n    let data = vm.$options.data;//用户传递的data\r\n    data = vm._data = typeof data === 'function'?data.call(vm):data;\r\n    // console.log(data);\r\n    // 对象劫持  用户改变了数据  我希望可以得到通知  后可以  刷新页面\r\n    // MVVM模式 数据变化可以驱动视图变化\r\n\r\n    //  Object.defineroperty() 给属性增加get方法和set方法\r\n    observe(data);//响应式原理\r\n\r\n    }\r\nfunction initComputed(){}\r\nfunction initWatch(){}","import {initState} from './state'\r\n// 在原型上添加一个init方法\r\nexport function initMixin(Vue){\r\n    Vue.prototype._init =function(options){\r\n    //    数据的劫持\r\n    const vm =this;//vue中使用this.$options 指代\r\n    vm.$options = options;\r\n\r\n    // 初始化状态\r\n    initState(vm);//分割代码\r\n    }\r\n}\r\n\r\n","// 自写vue的核心代码,只是vue的一个声明\r\nimport {initMixin} from './init';\r\nfunction Vue(options){\r\n    //进行vue的初始化操作\r\n    this._init(options);\r\n\r\n}\r\n// 通过引入文件的方式 给vue原型上添加方法\r\ninitMixin(Vue)  //给vue原型上添加一个_init方法\r\nexport default Vue"],"names":["isObject","data","def","key","value","Object","defineProperty","enumerable","configurable","oldArrayMethods","Array","prototype","arrayMethods","create","methods","forEach","method","console","log","args","result","apply","inserted","ob","__ob__","slice","observerArray","Observer","isArray","__proto__","walk","i","length","observe","keys","defineReactive","get","set","newValue","isObj","initState","vm","opts","$options","props","initData","computed","watch","_data","call","initMixin","Vue","_init","options"],"mappings":"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"}