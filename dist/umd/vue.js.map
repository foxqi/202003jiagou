{"version":3,"file":"vue.js","sources":["../../src/util/index.js","../../src/observe/array.js","../../src/observe/index.js","../../src/state.js","../../src/compiler/index.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 工具库\r\n/**\r\n * \r\n * @param {*} data  当前数据是不是对象\r\n */\r\n\r\nexport function isObject(data){\r\n    return typeof data === 'object' && data !==null\r\n}\r\n/**\r\n * 给对象增加属性\r\n * @param {*} data \r\n * @param {*} key \r\n * @param {*} value \r\n */\r\nexport function def(data,key,value){\r\n    Object.defineProperty(data,key,{\r\n        enumerable:false,\r\n        configurable:false,\r\n        value:value\r\n    })\r\n}\r\n\r\n\r\n","// 这里为什么要重写数组的方法呢，是因为用户是在前台把数组更新了，但是我们怎么获取更新的数组呢，只能在监听到用户传的方法也就是前面的value.__protp__=arrayMethods获取到所有的方法，然后这边在根据方法和传入的值在进行数组更新，然后在返回新的数组\r\n\r\n\r\n\r\n//  我要重写数组的哪些方法  ：7个  push shift  unshift  pop  reverse sort splice 会导致数组本身发生变化\r\n// slice（）这个方法并不会改变数组，就不用去通知了也不需要劫持，我们只监听数组变了的方法\r\n\r\n\r\n// 这就是原型链查找问题，会向上查找，先查找我重写的，重写的没有会继续向上查找\r\nlet oldArrayMethods = Array.prototype;//设置这个变量是为了如果用户调用了我们没有重写的方法（比如slice），会直接调用Array基类的方法\r\n// value.__propo__ = arrayMethods(数组通过原型链指向了arrayMethods)\r\n//arrayMethods.__propo__ = oldArrayMethods(arrayMethods通过原型链指向了oldArrayMethods)\r\nexport const arrayMethods = Object.create(oldArrayMethods); // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 也就是这端代码 等于 arrayMethods.__propo__ = oldArrayMethods\r\n\r\n\r\nconst methods = [\r\n    'push',\r\n    'shift',\r\n    'unshift',\r\n    'pop',\r\n    'sort',\r\n    'splice',\r\n    'reverse'\r\n]\r\n\r\nmethods.forEach(method=>{\r\n    // 在arrayMethods这个属性上增加上面那些方法，调这些方法的时候会传入很多参数\r\n    arrayMethods[method] = function(...args){//...agrs是{name: \"zf\", age: 3}\r\n        console.log('用户调用了方法');// AOP 切片编程  \r\n        const result = oldArrayMethods[method].apply(this,args);//调用原生的数组方法,这里的this指的是value,因为是value调用的,这个result返回的是value的length\r\n\r\n\r\n       // 判断：如果添加的元素可能还是一个对象\r\n\r\n        let inserted;//当前用户插入的元素\r\n        let ob =this.__ob__;//这里的this是指value，因为value在外面定义了value.__ob__=this;，这指向Observer的实例，而这个实例又有observerArray方法，所以可以调用observerArray方法\r\n        switch(method){\r\n            case 'push':\r\n            case 'usnshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':  //3个  新增的属性  splice 有删除 新增 的功能 arr.splice(0,1，{name:1})\r\n                inserted = args.slice(2);     //获取到最后新增的数据截取出来\r\n            default:\r\n                break;            \r\n        }\r\n        if(inserted) ob.observerArray(inserted);//将新增对象属性继续观测\r\n        return result;//这是是为了上面arrayMethods[method]=result,这个result就是为了改变this指向，让外面调用原生的方法\r\n    }\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// 把data中的数据 都使用Object.defineProperty重新定义  这是一个es5的方法\r\n// Object.defineProperty不能兼容ie8及以下，vue2无法兼容ie8版本\r\nimport {isObject,def} from '../util/index'\r\nimport {arrayMethods} from './array.js'\r\n/**\r\n *   步骤一：先创建一个Observer类进行数据监听，如果传入进来的data是个  对象  的话，遍历对象，用Object.defineProperty中的get和set方法进行数据变化的监听，如果对象里面嵌套对象，那么就用递归的方式进行深度监听\r\n *   步骤二：如果传入进来的data是个  数组   的话，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能，所以为了不给数组的索引进行get，set监听，遍历数组获得每个对象，在给里面的每个对象进行监听\r\n *    步骤三：当data是个数组的话，如果用户对这个数组进行了方法调用改变数组（比如用了push，unshift等方法）我们也要对方法进行重写，进行监听，并重新赋值。\r\n * （这一步的大概逻辑是：会导致数组本身发生变化的方法写成一个数组，然后遍历在调用原生方法，将原生方法进行输出，具体看array.js）\r\n *       \r\n * \r\n * \r\n * \r\n * \r\n * \r\n */\r\n\r\n\r\n\r\n/* 步骤一 start*/ \r\n\r\n//创建一个Observer的类\r\nclass Observer{\r\n   constructor(value){//这里的constructor是es6的新写法，一个类必须有 constructor 方法，一般 constructor 方法返回实例对象 this ，但是也可以指定  constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。\r\n    //这是constructor的概念https://www.jianshu.com/p/fc79756b1dc0\r\n\r\n\r\n/* 步骤三.2 start*/ \r\n//value.__ob__=this;//我给每一个监控过的对象都增加一个__ob__属性，这的this指的是Observer的实例,为了给后面的方法调用observerArray，进行数据监听\r\n// 上面的方法不能直接在vulue上加属性，因为下面的observe会进行数据监听，它会以为value增加新的数据，而上面的方法只是为了以后数据调用代码而进行赋值的，所以只能用下面的方法\r\n     def(value,'__ob__',this)\r\n/* 步骤三 end*/\r\n\r\n/* 步骤二 start*/ \r\n\r\n    // 如果是传进来的是数组，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能\r\n    if(Array.isArray(value)){\r\n        //如果是数组的话并不会对索引进行观测，因为会导致性能问题\r\n        // 前端开发中很少很少  去操作索引  push  shift  unshift\r\n\r\n/* 步骤三.1 start*/ \r\n       value.__proto__= arrayMethods;\r\n/* 步骤三 end*/ \r\n\r\n\r\n        // 如果数组里放的是对象我在监控\r\n        this.observerArray(value);\r\n    }else{\r\n        //vue如果数据的层次过多，需要递归的去解析对象中的属性，依次增加set和get方法\r\n        this.walk(value)// 先考虑一步的数据\r\n    }\r\n\r\n   }\r\n\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤二 start*/   \r\n//这个方法是为了不给数组的索引进行get，set监听，直接遍历数组获得每个对象，在给对象进行监听\r\n   observerArray(value){//value是[{}],用observe监控了数组的每一项\r\n        for(let i=0; i<value.length;i++){\r\n            observe(value[i])\r\n        }\r\n   }\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤一 start*/ \r\n   walk(data){\r\n       let keys = Object.keys(data); //[name,age,address]\r\n\r\n    //    for(let i=0;i<keys.length;i++){\r\n    //         let key =keys[i];\r\n    //         let value =data[key];\r\n    //         defineReactive(data,key,value);//定义响应式数据\r\n    //     }\r\n    // 可以简化为下面的代码\r\n        keys.forEach((key)=>{\r\n            defineReactive(data,key,data[key]);//定义响应式数据\r\n        })\r\n\r\n      \r\n   }\r\n/* 步骤一 end*/ \r\n}\r\n/* 步骤一 start*/  \r\nfunction defineReactive(data,key,value){\r\n    observe(value);//这里的调用，是为了递归，获取到对象中的对象的属性:递归实现深度检测，但是如果层级太多使用递归会很浪费性能\r\n    Object.defineProperty(data,key,{\r\n        get(){//获取值的时候作一些操作\r\n           return value;\r\n        },\r\n        set(newValue){//当数据发生变化，也可以设置一些操作\r\n\r\n            console.log('更新数据')\r\n\r\n\r\n           if(newValue === value)  return;\r\n           observe(newValue);//继续劫持用户设置的值，因为有可能用户设置的值是一个对象；这里深度劫持就会在这个对象里有set和get方法，就能再次进行更改监听\r\n           value = newValue\r\n        }\r\n    })\r\n}\r\n/* 步骤一 end*/ \r\n\r\n/* 步骤一 start*/  \r\n\r\n// 这里是输出Observer观察到的数据\r\nexport function observe(data){\r\n    let isObj = isObject(data);\r\n    if(!isObj){\r\n        return;\r\n    }   \r\n   return new Observer(data)  // 用来观测数据\r\n \r\n}\r\n/* 步骤一 end*/\r\n\r\n\r\n","import {observe} from './observe/index.js'\r\nexport function initState(vm){\r\n    const opts = vm.$options;\r\n   //监测的顺序 vue的数据来源  属性  方法  数据  计算属性  watch\r\n   if(opts.props){\r\n       initProps(vm);\r\n   }\r\n   if(opts.methods){\r\n       initMethod(vm)\r\n   }\r\n   if(opts.data){\r\n       initData(vm)\r\n   }\r\n   if(opts.computed){\r\n       initComputed(vm)\r\n   }\r\n   if(opts.watch){\r\n       initWatch(vm)\r\n   }\r\n}\r\nfunction initProps(){}\r\nfunction initMethod(){}\r\nfunction initData(vm){\r\n    //   数据初始化工作\r\n    let data = vm.$options.data;//用户传递的data\r\n    data = vm._data = typeof data === 'function'?data.call(vm):data;\r\n    // console.log(data);\r\n    // 对象劫持  用户改变了数据  我希望可以得到通知  后可以  刷新页面\r\n    // MVVM模式 数据变化可以驱动视图变化\r\n\r\n    //  Object.defineroperty() 给属性增加get方法和set方法\r\n    observe(data);//1.响应式原理\r\n\r\n    }\r\nfunction initComputed(){}\r\nfunction initWatch(){}","//将html变成函数的话，会用到ast语法树\r\n/*ast语法树  和 虚拟到dom有什么区别\r\nast语法树 是 用对象来编译html语法的（下面的原理）\r\n虚拟dom 是  用对象来描述dom节点的（也就是那个html下面有div标签，div下面有p，span标签等的dom节点）\r\n\r\n\r\n\r\nrender函数返回的是虚拟dom，现在做的是把template变成render函数\r\n*/  \r\n\r\n// vue源码\r\n// ?:匹配不补货\r\n const ncname = '[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*'//命名空间：表示能匹配到abc-aaa这样的一个字符串\r\n const qnameCapture = `((?:${ncname}\\\\:)?${ncname})`//命名空间标签：<aaa:asdee>\r\n // 匹配开始标签开始部分\r\n const startTagOpen = new RegExp(`^<${qnameCapture}`)//标签开头的正则，捕获的内容是标签名\r\n\r\n\r\n/**\r\n * 这是验证上面的正则是否正确\r\n * let r = '<a:b>'.match(startTagOpen);\r\n * console.log(r)\r\n * \r\n * 获得这样的东西  [\"<a:b\", \"a:b\", index: 0, input: \"<a:b>\", groups: undefined]\r\n * \r\n * arguments[0] = 匹配到的标签  arguments[1] = 匹配到的标签名字 \r\n */\r\n const endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)// 匹配标签结尾的闭比如</div>\r\n const attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/ // 匹配属性\r\n const startTagClose = /^\\s*(\\/?)>/   // 匹配标签结束的 >\r\n const defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g // 匹配默认的分隔符 \"{{}}\"\r\n\r\n function start(tagName,attrs){\r\n    console.log('开始标签：',tagName,'属性是：',attrs);\r\n    \r\n }\r\n\r\nfunction parseHTML(html){\r\n    // 不停的解析html\r\n   while (html){\r\n      let textEnd = html.indexOf('<');\r\n      if(textEnd == 0){\r\n        //   如果当前索引为0  肯定是一个标签  开始标签  结束标签\r\n       let startTagMatch = parseSartTag();//通过这个方法获取到匹配的结果 tagName，attrs\r\n       start(startTagMatch.tagName,startTagMatch.attrs)\r\n      }  \r\n      let text;\r\n      if(textEnd >= 0){\r\n          text = html.substring(0,textEnd)\r\n      }\r\n      if(text){\r\n          advance(text.length);\r\n          ChannelSplitterNode(text)\r\n          break;\r\n      }\r\n   }\r\n   function advance(n){\r\n      html = html.substring(n);\r\n   }\r\n    function parseSartTag(){\r\n        let start = html.match(startTagOpen)\r\n        if(start){\r\n            const match={\r\n                tagName:start[1],\r\n                attrs:[]\r\n            }\r\n            advance(start[0].length);//将标签删除\r\n            let end,attr ;\r\n            while(!(end = html.match(startTagClose)) && (attr = html.match(attribute))  ){\r\n                // 将属性进行解析\r\n                advance(start[0].length);//将属性去掉\r\n                match.attrs.push({\r\n                    name:attr[1],\r\n                    value:attr[3] || attr[4] || attr[5]\r\n                });//放在了attrs这个属性中\r\n    \r\n            }\r\n            if(end){//去掉开始标签的 >\r\n                advance(end[0].length);\r\n            }\r\n            return match\r\n            console.log(match)\r\n            console.log(html)\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function compileToFunction(template){\r\n    console.log(template,'---');\r\n    let root = parseHTML(template)\r\n\r\n    return function render(){\r\n\r\n    }\r\n}\r\n/**\r\n * 通过上面的正则，可以把下面的html编译成\r\n * start div:  attr:[{name:'id',value:'app'}]\r\n * start p\r\n * text hello\r\n * end p\r\n * end div \r\n */\r\n/*\r\n<div id=\"app\">\r\n    <p>hello</p>\r\n</div>\r\n//上面的html就会变成下面的抽象的语法，这就是ast语法树\r\n这个root就是ast语法树\r\nlet root ={\r\n    tag:'div',\r\n    attrs:[//属性\r\n        {name:'id',value:'app'}\r\n    ],\r\n    parent:null,\r\n    type:1,//它是什么类型，元素类型为1\r\n    children:[{\r\n        tag:'p',\r\n        attrs:[],\r\n        parent:root,\r\n        children:[{\r\n            text:'hello',\r\n            type:3,//文本类型为1\r\n            }]\r\n    }]\r\n}\r\n*/ \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import {initState} from './state'\r\n\r\nimport {compileToFunction} from './compiler/index.js'\r\n// 在原型上添加一个init方法\r\nexport function initMixin(Vue){\r\n    Vue.prototype._init =function(options){\r\n    //    数据的劫持\r\n    const vm =this;//vue中使用this.$options 指代\r\n    vm.$options = options;\r\n\r\n    // 初始化状态\r\n    initState(vm);//分割代码（这里面有1.数据劫持）\r\n\r\n\r\n\r\n\r\n\r\n    // 2.模板编译\r\n    // 如果用户传入了el属性  需要将页面渲染出出来\r\n    // 如果用户传入了el  就要实现挂载流程\r\n     if(vm.$options.el){\r\n         vm.$mount(vm.$options.el);\r\n     }\r\n\r\n    }\r\n    Vue.prototype.$mount = function(el){\r\n        const vm = this;\r\n        const options = vm.$options;\r\n        el = document.querySelector(el);\r\n\r\n        // 默认先会查找有没有render方法，没有render  会 采用template， template也没有就用el中的内容\r\n        if(!options.render){\r\n            // 对模板进行编译\r\n            let template = options.template;//取出模板\r\n            if(!template && el){\r\n                template = el.outerHTML;\r\n            }\r\n            // console.log(template);\r\n            /*这是拿到的template的模板\r\n            <div id=\"app\">\r\n                <p>{{name}}</p>\r\n                <span>{{age}}</span>\r\n            </div>*/\r\n\r\n            // 我们需要将template  转换成render方法\r\n            // vue1.0是用的纯字符串编译，正则转换的方式，性能不高；vue2.0引用的是虚拟dom\r\n            /* 将上面的拿到的template模板，用render函数写成：\r\n            render(){  //_c是creatElement创建一个元素div； 有一些属性{id:'app'}： \r\n            有俩个儿子  p没有属性undefined; p里面有文本，创建一个文本_v;  _s表示的是json.stringify取值，转成一个对象格式或字符串格式，创建出来一个文本;  span同理\r\n            这样就创建出一个虚拟节点，变成上面的html\r\n                return _c('div',{id:'app'},_c('p',undefined,_v(_s(name))),_c('span',undefined,_v(_s(age))))\r\n            }\r\n            */\r\n            // 模板进行编译用compileToFunction这个函数(自己封装的)，也就是把template这个html编译成一个函数\r\n            const render =compileToFunction(template);\r\n            options.render = render;//这个是为了用户传了render用用户传的，用户没传，就用自己写的\r\n        }\r\n    \r\n    \r\n    }\r\n}\r\n\r\n","// 自写vue的核心代码,只是vue的一个声明\r\nimport {initMixin} from './init';\r\nfunction Vue(options){\r\n    //进行vue的初始化操作\r\n    this._init(options);\r\n\r\n}\r\n// 通过引入文件的方式 给vue原型上添加方法\r\ninitMixin(Vue)  //给vue原型上添加一个_init方法\r\nexport default Vue"],"names":["isObject","data","def","key","value","Object","defineProperty","enumerable","configurable","oldArrayMethods","Array","prototype","arrayMethods","create","methods","forEach","method","console","log","args","result","apply","inserted","ob","__ob__","slice","observerArray","Observer","isArray","__proto__","walk","i","length","observe","keys","defineReactive","get","set","newValue","isObj","initState","vm","opts","$options","props","initData","computed","watch","_data","call","ncname","qnameCapture","startTagOpen","RegExp","attribute","startTagClose","start","tagName","attrs","parseHTML","html","textEnd","indexOf","startTagMatch","parseSartTag","text","substring","advance","ChannelSplitterNode","n","match","end","attr","push","name","compileToFunction","template","root","render","initMixin","Vue","_init","options","el","$mount","document","querySelector","outerHTML"],"mappings":"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"}