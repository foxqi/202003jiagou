{"version":3,"file":"vue.js","sources":["../../src/util/index.js","../../src/observe/array.js","../../src/observe/index.js","../../src/state.js","../../src/compiler/parser-html.js","../../src/compiler/index.js","../../src/init.js","../../src/index.js"],"sourcesContent":["// 工具库\r\n/**\r\n * \r\n * @param {*} data  当前数据是不是对象\r\n */\r\n\r\nexport function isObject(data){\r\n    return typeof data === 'object' && data !==null\r\n}\r\n/**\r\n * 给对象增加属性\r\n * @param {*} data \r\n * @param {*} key \r\n * @param {*} value \r\n */\r\nexport function def(data,key,value){\r\n    Object.defineProperty(data,key,{\r\n        enumerable:false,\r\n        configurable:false,\r\n        value:value\r\n    })\r\n}\r\n\r\n\r\n","// 这里为什么要重写数组的方法呢，是因为用户是在前台把数组更新了，但是我们怎么获取更新的数组呢，只能在监听到用户传的方法也就是前面的value.__protp__=arrayMethods获取到所有的方法，然后这边在根据方法和传入的值在进行数组更新，然后在返回新的数组\r\n\r\n\r\n\r\n//  我要重写数组的哪些方法  ：7个  push shift  unshift  pop  reverse sort splice 会导致数组本身发生变化\r\n// slice（）这个方法并不会改变数组，就不用去通知了也不需要劫持，我们只监听数组变了的方法\r\n\r\n\r\n// 这就是原型链查找问题，会向上查找，先查找我重写的，重写的没有会继续向上查找\r\nlet oldArrayMethods = Array.prototype;//设置这个变量是为了如果用户调用了我们没有重写的方法（比如slice），会直接调用Array基类的方法\r\n// value.__propo__ = arrayMethods(数组通过原型链指向了arrayMethods)\r\n//arrayMethods.__propo__ = oldArrayMethods(arrayMethods通过原型链指向了oldArrayMethods)\r\nexport const arrayMethods = Object.create(oldArrayMethods); // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 也就是这端代码 等于 arrayMethods.__propo__ = oldArrayMethods\r\n\r\n\r\nconst methods = [\r\n    'push',\r\n    'shift',\r\n    'unshift',\r\n    'pop',\r\n    'sort',\r\n    'splice',\r\n    'reverse'\r\n]\r\n\r\nmethods.forEach(method=>{\r\n    // 在arrayMethods这个属性上增加上面那些方法，调这些方法的时候会传入很多参数\r\n    arrayMethods[method] = function(...args){//...agrs是{name: \"zf\", age: 3}\r\n        console.log('用户调用了方法');// AOP 切片编程  \r\n        const result = oldArrayMethods[method].apply(this,args);//调用原生的数组方法,这里的this指的是value,因为是value调用的,这个result返回的是value的length\r\n\r\n\r\n       // 判断：如果添加的元素可能还是一个对象\r\n\r\n        let inserted;//当前用户插入的元素\r\n        let ob =this.__ob__;//这里的this是指value，因为value在外面定义了value.__ob__=this;，这指向Observer的实例，而这个实例又有observerArray方法，所以可以调用observerArray方法\r\n        switch(method){\r\n            case 'push':\r\n            case 'usnshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':  //3个  新增的属性  splice 有删除 新增 的功能 arr.splice(0,1，{name:1})\r\n                inserted = args.slice(2);     //获取到最后新增的数据截取出来\r\n            default:\r\n                break;            \r\n        }\r\n        if(inserted) ob.observerArray(inserted);//将新增对象属性继续观测\r\n        return result;//这是是为了上面arrayMethods[method]=result,这个result就是为了改变this指向，让外面调用原生的方法\r\n    }\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// 把data中的数据 都使用Object.defineProperty重新定义  这是一个es5的方法\r\n// Object.defineProperty不能兼容ie8及以下，vue2无法兼容ie8版本\r\nimport {isObject,def} from '../util/index'\r\nimport {arrayMethods} from './array.js'\r\n/**\r\n *   步骤一：先创建一个Observer类进行数据监听，如果传入进来的data是个  对象  的话，遍历对象，用Object.defineProperty中的get和set方法进行数据变化的监听，如果对象里面嵌套对象，那么就用递归的方式进行深度监听\r\n *   步骤二：如果传入进来的data是个  数组   的话，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能，所以为了不给数组的索引进行get，set监听，遍历数组获得每个对象，在给里面的每个对象进行监听\r\n *    步骤三：当data是个数组的话，如果用户对这个数组进行了方法调用改变数组（比如用了push，unshift等方法）我们也要对方法进行重写，进行监听，并重新赋值。\r\n * （这一步的大概逻辑是：会导致数组本身发生变化的方法写成一个数组，然后遍历在调用原生方法，将原生方法进行输出，具体看array.js）\r\n *       \r\n * \r\n * \r\n * \r\n * \r\n * \r\n */\r\n\r\n\r\n\r\n/* 步骤一 start*/ \r\n\r\n//创建一个Observer的类\r\nclass Observer{\r\n   constructor(value){//这里的constructor是es6的新写法，一个类必须有 constructor 方法，一般 constructor 方法返回实例对象 this ，但是也可以指定  constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。\r\n    //这是constructor的概念https://www.jianshu.com/p/fc79756b1dc0\r\n\r\n\r\n/* 步骤三.2 start*/ \r\n//value.__ob__=this;//我给每一个监控过的对象都增加一个__ob__属性，这的this指的是Observer的实例,为了给后面的方法调用observerArray，进行数据监听\r\n// 上面的方法不能直接在vulue上加属性，因为下面的observe会进行数据监听，它会以为value增加新的数据，而上面的方法只是为了以后数据调用代码而进行赋值的，所以只能用下面的方法\r\n     def(value,'__ob__',this)\r\n/* 步骤三 end*/\r\n\r\n/* 步骤二 start*/ \r\n\r\n    // 如果是传进来的是数组，那么它会对索引进行监听并附有get和set方法,如果有一百万个数组那么会监听一百万次，很浪费性能\r\n    if(Array.isArray(value)){\r\n        //如果是数组的话并不会对索引进行观测，因为会导致性能问题\r\n        // 前端开发中很少很少  去操作索引  push  shift  unshift\r\n\r\n/* 步骤三.1 start*/ \r\n       value.__proto__= arrayMethods;\r\n/* 步骤三 end*/ \r\n\r\n\r\n        // 如果数组里放的是对象我在监控\r\n        this.observerArray(value);\r\n    }else{\r\n        //vue如果数据的层次过多，需要递归的去解析对象中的属性，依次增加set和get方法\r\n        this.walk(value)// 先考虑一步的数据\r\n    }\r\n\r\n   }\r\n\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤二 start*/   \r\n//这个方法是为了不给数组的索引进行get，set监听，直接遍历数组获得每个对象，在给对象进行监听\r\n   observerArray(value){//value是[{}],用observe监控了数组的每一项\r\n        for(let i=0; i<value.length;i++){\r\n            observe(value[i])\r\n        }\r\n   }\r\n/* 步骤二 end*/ \r\n\r\n/* 步骤一 start*/ \r\n   walk(data){\r\n       let keys = Object.keys(data); //[name,age,address]\r\n\r\n    //    for(let i=0;i<keys.length;i++){\r\n    //         let key =keys[i];\r\n    //         let value =data[key];\r\n    //         defineReactive(data,key,value);//定义响应式数据\r\n    //     }\r\n    // 可以简化为下面的代码\r\n        keys.forEach((key)=>{\r\n            defineReactive(data,key,data[key]);//定义响应式数据\r\n        })\r\n\r\n      \r\n   }\r\n/* 步骤一 end*/ \r\n}\r\n/* 步骤一 start*/  \r\nfunction defineReactive(data,key,value){\r\n    observe(value);//这里的调用，是为了递归，获取到对象中的对象的属性:递归实现深度检测，但是如果层级太多使用递归会很浪费性能\r\n    Object.defineProperty(data,key,{\r\n        get(){//获取值的时候作一些操作\r\n           return value;\r\n        },\r\n        set(newValue){//当数据发生变化，也可以设置一些操作\r\n\r\n            console.log('更新数据')\r\n\r\n\r\n           if(newValue === value)  return;\r\n           observe(newValue);//继续劫持用户设置的值，因为有可能用户设置的值是一个对象；这里深度劫持就会在这个对象里有set和get方法，就能再次进行更改监听\r\n           value = newValue\r\n        }\r\n    })\r\n}\r\n/* 步骤一 end*/ \r\n\r\n/* 步骤一 start*/  \r\n\r\n// 这里是输出Observer观察到的数据\r\nexport function observe(data){\r\n    let isObj = isObject(data);\r\n    if(!isObj){\r\n        return;\r\n    }   \r\n   return new Observer(data)  // 用来观测数据\r\n \r\n}\r\n/* 步骤一 end*/\r\n\r\n\r\n","import {observe} from './observe/index.js'\r\nexport function initState(vm){\r\n    const opts = vm.$options;\r\n   //监测的顺序 vue的数据来源  属性  方法  数据  计算属性  watch\r\n   if(opts.props){\r\n       initProps(vm);\r\n   }\r\n   if(opts.methods){\r\n       initMethod(vm)\r\n   }\r\n   if(opts.data){\r\n       initData(vm)\r\n   }\r\n   if(opts.computed){\r\n       initComputed(vm)\r\n   }\r\n   if(opts.watch){\r\n       initWatch(vm)\r\n   }\r\n}\r\nfunction initProps(){}\r\nfunction initMethod(){}\r\nfunction initData(vm){\r\n    //   数据初始化工作\r\n    let data = vm.$options.data;//用户传递的data\r\n    data = vm._data = typeof data === 'function'?data.call(vm):data;\r\n    // console.log(data);\r\n    // 对象劫持  用户改变了数据  我希望可以得到通知  后可以  刷新页面\r\n    // MVVM模式 数据变化可以驱动视图变化\r\n\r\n    //  Object.defineroperty() 给属性增加get方法和set方法\r\n    observe(data);//1.响应式原理\r\n\r\n    }\r\nfunction initComputed(){}\r\nfunction initWatch(){}","\r\n\r\n// vue源码\r\n// ?:匹配不补货\r\n\r\nconst ncname = '[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*'//命名空间：表示能匹配到abc-aaa这样的一个字符串\r\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`//命名空间标签：<aaa:asdee>\r\n// 匹配开始标签开始部分\r\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)//标签开头的正则，捕获的内容是标签名\r\n\r\n\r\n/**\r\n * 这是验证上面的正则是否正确\r\n * let r = '<a:b>'.match(startTagOpen);\r\n * console.log(r)\r\n * \r\n * 获得这样的东西  [\"<a:b\", \"a:b\", index: 0, input: \"<a:b>\", groups: undefined]\r\n * \r\n * arguments[0] = 匹配到的标签  arguments[1] = 匹配到的标签名字 \r\n */\r\n\r\n\r\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)// 匹配标签结尾的闭比如</div>\r\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/ // 匹配属性\r\nconst startTagClose = /^\\s*(\\/?)>/   // 匹配标签结束的 >\r\nconst defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g // 匹配默认的分隔符 \"{{}}\"\r\n\r\n\r\nlet root = null;//ast语法树的树根\r\nlet currentParent;//标识当前父亲是谁\r\nlet stack = [];\r\nconst ELEMENT_TYPE = 1;\r\nconst TEXT_TYPE = 3;\r\n\r\nfunction createASTElement(tagName, attrs) {\r\n    return {\r\n        tag: tagName,\r\n        type: ELEMENT_TYPE,\r\n        children: [],\r\n        attrs,\r\n        parent: null\r\n    }\r\n}\r\n\r\nfunction start(tagName, attrs) {\r\n    //console.log('开始标签：', tagName, '属性是：', attrs);\r\n    //遇到开始标签 就创建一个ast元素\r\n    let element = createASTElement(tagName, attrs);\r\n    if (!root) {\r\n        root = element;\r\n    }\r\n    currentParent = element;//把当前元素标记成父ast树\r\n    stack.push(element);//将开始标签存放在栈中\r\n\r\n}\r\nfunction chars(text) {\r\n    // console.log('文本是：', text)\r\n    text =text.replace(/\\s/g,'');\r\n    if(text){\r\n        currentParent.children.push({\r\n            text,\r\n            type:TEXT_TYPE\r\n        })\r\n    }\r\n}\r\nfunction end(tagName) {\r\n    // console.log('结束标签', tagName)\r\n    let element = stack.pop();//拿到的是ast对象\r\n    //我要标识当前这个p是属于这个div的儿子的\r\n    currentParent = stack[stack.length-1];\r\n    if(currentParent){\r\n        element.parent = currentParent;\r\n        currentParent.children.push(element);//实现了一个树的父子关系\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function parseHTML(html) {\r\n    // 不停的解析html\r\n    while (html) {\r\n        let textEnd = html.indexOf('<');\r\n        if (textEnd == 0) {\r\n            //   如果当前索引为0  肯定是一个标签  开始标签  结束标签\r\n            let startTagMatch = parseSartTag();//通过这个方法获取到匹配的结果 tagName，attrs\r\n            if (startTagMatch) {\r\n                start(startTagMatch.tagName, startTagMatch.attrs)//1.解析开始标签\r\n                continue;//如果开始标签匹配完毕后，继续下一次 匹配\r\n            }\r\n            let endTagMatch = html.match(endTag);\r\n            if (endTagMatch) {\r\n                advance(endTagMatch[0].length);\r\n                end(endTagMatch);//2.解析结束标签\r\n                continue;\r\n            }\r\n        }\r\n        let text;\r\n        if (textEnd >= 0) {\r\n            text = html.substring(0, textEnd)\r\n        }\r\n        if (text) {\r\n            advance(text.length);\r\n            chars(text)//3.解析文本\r\n        }\r\n    }\r\n    function advance(n) {\r\n        html = html.substring(n);\r\n    }\r\n    function parseSartTag() {\r\n        let start = html.match(startTagOpen)\r\n        if (start) {\r\n            const match = {\r\n                tagName: start[1],\r\n                attrs: []\r\n            }\r\n            advance(start[0].length);//将标签删除\r\n\r\n            let end, attr;\r\n            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\r\n                // 将属性进行解析\r\n                advance(attr[0].length);//将属性去掉\r\n                match.attrs.push({\r\n                    name: attr[1],\r\n                    value: attr[3] || attr[4] || attr[5]\r\n                });//放在了attrs这个属性中\r\n\r\n            }\r\n            if (end) {//去掉开始标签的 >\r\n                advance(end[0].length);\r\n                return match\r\n            }\r\n        }\r\n    }\r\n    return root;\r\n}","//将html变成函数的话，会用到ast语法树\r\n/*ast语法树  和 虚拟到dom有什么区别\r\nast语法树 是 用对象来编译html语法的（下面的原理）\r\n虚拟dom 是  用对象来描述dom节点的（也就是那个html下面有div标签，div下面有p，span标签等的dom节点）\r\n\r\n\r\n\r\nrender函数返回的是虚拟dom，现在做的是把template变成render函数\r\n\r\n\r\n把html不停的循环，拿出来之后组成一个树，这个树描述了一个dom结构\r\n*/\r\n\r\nimport { parseHTML } from './parser-html'\r\n\r\nfunction genProps(attrs) {//处理属性，拼接成属性的字符串\r\n    let str = '';\r\n    for (let i = 0; i < attrs.length; i++) {\r\n        let attr = attrs[i];\r\n        if (attr.name === 'style') {\r\n            //style=\"color:red;font-size:14px\" => {style:{color:'red'},id:name}\r\n            let obj = {};\r\n            attr.value.split(';').forEach(item => {\r\n                let [key, value] = item.split(':');\r\n                obj[key] = value\r\n            });\r\n            attr.value = obj;\r\n        }\r\n        str += `${attr.name}:${JSON.stringify(attr.value)},`\r\n    }\r\n    return `{${str.slice(0, -1)}}`\r\n}\r\n\r\nfunction generate(el) {//[{name:'id',value:'app'},{}]  => {id:app,a:1,b:2}\r\n    let code = `_c(\"${el.tag}\",${\r\n        el.attrs.length ? genProps(el.attrs) : 'undefined'\r\n        })\r\n    \r\n    `\r\n    return code;\r\n}\r\n\r\nexport function compileToFunction(template) {\r\n    //console.log(template, '---');\r\n    //1）解析html字符串，将html字符串 => ast语法树\r\n    let root = parseHTML(template)\r\n    // console.log(root)\r\n\r\n\r\n    let code = generate(root);\r\n\r\n    //2)需要将ast语法树生成最终的render函数  就是字符串拼接 （模板引擎）\r\n    // 核心思路就是将模板转换成 下面这段字符串\r\n    // <div id=\"app\">hello<p>{{name}}</p><span>{{age}}</span></div>\r\n    // 将ast树，再次转换成js的语法树\r\n    // _c('div',{id:'app'},_c('p',undefined,_v(_s(name))),_c('span',undefined,_v(_s(age))))\r\n    console.log(code);\r\n\r\n    return function render() {\r\n\r\n    }\r\n}\r\n/**\r\n * 通过上面的正则，可以把下面的html编译成\r\n * start div:  attr:[{name:'id',value:'app'}]\r\n * start p\r\n * text hello\r\n * end p\r\n * end div\r\n */\r\n/*\r\n<div id=\"app\">\r\n    <p>hello</p>\r\n</div>\r\n//上面的html就会变成下面的抽象的语法，这就是ast语法树\r\n这个root就是ast语法树\r\nlet root ={\r\n    tag:'div',\r\n    attrs:[//属性\r\n        {name:'id',value:'app'}\r\n    ],\r\n    parent:null,\r\n    type:1,//它是什么类型，元素类型为1\r\n    children:[{\r\n        tag:'p',\r\n        attrs:[],\r\n        parent:root,\r\n        children:[{\r\n            text:'hello',\r\n            type:3,//文本类型为1\r\n            }]\r\n    }]\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import {initState} from './state'\r\n\r\nimport {compileToFunction} from './compiler/index.js'\r\n// 在原型上添加一个init方法\r\nexport function initMixin(Vue){\r\n    Vue.prototype._init =function(options){\r\n    //    数据的劫持\r\n    const vm =this;//vue中使用this.$options 指代\r\n    vm.$options = options;\r\n\r\n    // 初始化状态\r\n    initState(vm);//分割代码（这里面有1.数据劫持）\r\n\r\n\r\n\r\n\r\n\r\n    // 2.模板编译\r\n    // 如果用户传入了el属性  需要将页面渲染出出来\r\n    // 如果用户传入了el  就要实现挂载流程\r\n     if(vm.$options.el){\r\n         vm.$mount(vm.$options.el);\r\n     }\r\n\r\n    }\r\n    Vue.prototype.$mount = function(el){\r\n        const vm = this;\r\n        const options = vm.$options;\r\n        el = document.querySelector(el);\r\n\r\n        // 默认先会查找有没有render方法，没有render  会 采用template， template也没有就用el中的内容\r\n        if(!options.render){\r\n            // 对模板进行编译\r\n            let template = options.template;//取出模板\r\n            if(!template && el){\r\n                template = el.outerHTML;\r\n            }\r\n            // console.log(template);\r\n            /*这是拿到的template的模板\r\n            <div id=\"app\">\r\n                <p>{{name}}</p>\r\n                <span>{{age}}</span>\r\n            </div>*/\r\n\r\n            // 我们需要将template  转换成render方法\r\n            // vue1.0是用的纯字符串编译，正则转换的方式，性能不高；vue2.0引用的是虚拟dom\r\n            /* 将上面的拿到的template模板，用render函数写成：\r\n            render(){  //_c是creatElement创建一个元素div； 有一些属性{id:'app'}： \r\n            有俩个儿子  p没有属性undefined; p里面有文本，创建一个文本_v;  _s表示的是json.stringify取值，转成一个对象格式或字符串格式，创建出来一个文本;  span同理\r\n            这样就创建出一个虚拟节点，变成上面的html\r\n                return _c('div',{id:'app'},_c('p',undefined,_v(_s(name))),_c('span',undefined,_v(_s(age))))\r\n            }\r\n            */\r\n            // 模板进行编译用compileToFunction这个函数(自己封装的)，也就是把template这个html编译成一个函数\r\n            const render =compileToFunction(template);\r\n            options.render = render;//这个是为了用户传了render用用户传的，用户没传，就用自己写的\r\n        }\r\n    \r\n    \r\n    }\r\n}\r\n\r\n","// 自写vue的核心代码,只是vue的一个声明\r\nimport {initMixin} from './init';\r\nfunction Vue(options){\r\n    //进行vue的初始化操作\r\n    this._init(options);\r\n\r\n}\r\n// 通过引入文件的方式 给vue原型上添加方法\r\ninitMixin(Vue)  //给vue原型上添加一个_init方法\r\nexport default Vue"],"names":["isObject","data","def","key","value","Object","defineProperty","enumerable","configurable","oldArrayMethods","Array","prototype","arrayMethods","create","methods","forEach","method","console","log","args","result","apply","inserted","ob","__ob__","slice","observerArray","Observer","isArray","__proto__","walk","i","length","observe","keys","defineReactive","get","set","newValue","isObj","initState","vm","opts","$options","props","initData","computed","watch","_data","call","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","root","currentParent","stack","ELEMENT_TYPE","TEXT_TYPE","createASTElement","tagName","attrs","tag","type","children","parent","start","element","push","chars","text","replace","end","pop","parseHTML","html","textEnd","indexOf","startTagMatch","parseSartTag","endTagMatch","match","advance","substring","n","attr","name","genProps","str","obj","split","item","JSON","stringify","generate","el","code","compileToFunction","template","render","initMixin","Vue","_init","options","$mount","document","querySelector","outerHTML"],"mappings":"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"}